%Parallel programming models such as 
OpenMP has been evolved to be a comprehensive programming model for parallel and heterogeneous computing nodes by including 
data parallelism, task parallelism, offloading execution model, etc. in one unified model. 
The runtime systems are becoming more complicated than before support those language features.
A typical OpenMP runtime maintains an internal thread pool to keep tracking those threads allocated by the runtime even they are not  
doing any OpenMP operation during the sequential execution of the program. 
A thread in the thread pool could be in either busy-waiting state which occupies a CPU core, or in the kernel
scheduling queue after a yield system call (e.g. {\em sched\_yield} in Linux), or could be put to sleep. Some OpenMP runtime also maintains
internal hot teams of which threads are busy-waiting for work even if the program is in the sequential stage. So an OpenMP program could 
consumes cycles of multiple CPU cores even if it is in sequential execution stage.

This interoperability proposal attemps to address the oversubscription (both CPU and memory) challenges by providing more information or control
to users for the threads in the runtime. The proposal also provides mechanism for an OpenMP runtime to interact with externals, including 
contributing OpenMP threads for another parallel runtime, for processing tasks such as message passing that are not computational, or for receiving
help from user threads to do OpenMP work. We also observed that a highly-interoperable OpenMP implementation are 
complicated for both the usage and implementation of those features. It introduces
overheads that may not be necessnary for a program that does not need to interoperate in that degree of interoperability. 
Thus our principle to support OpenMP interoperability is by 
categorizing interoperability functionalities into multiple levels. In each level, 
OpenMP constructs (directives, runtime APIs and environment variables) are defined to support the interoperability 
requirements. 
\begin{itemize}
	\item {\bf Level 0, OMP\_INTEROP\_NONE}: No interoperability. The OpenMP runtime do not provide mechanism to interoperate with others.
	\item {\bf Level 1, OMP\_INTEROP\_INFORM}, Informational. Constructs for providing information for others about the internal status of the thread pool, memory affinity info, etc. 
	\item {\bf Level 2, OMP\_INTEROP\_SELF}: Self adjusting threading behavior. Constructs for
		externals to use to adjust its internal threading and affinity behaviors.
	\item {\bf Level 3, OMP\_INTEROP\_CONTRIBUTE}: Contributing. Constructs for externals to use to acquire OpenMP 
		threads or place for doing user-specific tasks that are not part of the OpenMP. It also includes constructs for injecting
		a user-specific task into the runtime. 
	\item {\bf Level 4, OMP\_INTEROP\_RECEIVE}: Receiving help. Consturcts for externals to attach user threads or memory affinity into the runtime.
\end{itemize}

An OpenMP implementation that supports the certain level of interoperability should provide the implementation of all the APIs
from level 0 to that level inclusively. 
An environment variable, {\sf OMP\_INTEROP\_LEVEL}, is defined to set the desired level of 
interoperability for an OpenMP program. The actual level during execution depends on both the value of 
the variable and the level which the implementation supports. 
The ``{\sf int omp\_get\_interop\_level()}" procedure should be provided for querying the current level. % being supported by an OpenMP runtime. 
%An OpenMP implementation supports the desired level of interoperability and should 

\subsection{Level 0, OMP\_INTEROP\_NONE}
In this level, an OpenMP runtime should be independent from others, even another instance of the same library. 
An OpenMP runtime instance should be created for each user thread that launch 
into OpenMP functions. 
\subsection{Level 1, OMP\_INTEROP\_INFORM} 
\subsection{Level 2, OMP\_INTEROP\_SELF} 
\subsection{Level 3, OMP\_INTEROP\_CONTRIBUTE} 
\subsection{Level 4, OMP\_INTEROP\_RECEIVE} 

%\subsubsection{Posibble Solutions and Proposals}
The current support in OpenMP provides limited constrol on oversubscriptions, but are sufficient 
for lots of (if not most of) scenarios if the implemention is available. In the following of this
report, we propose solutions that will provide more
control for oversubscription.
\subsubsection{Change wait policy dynamically to address passive oversubscription}
The idea is to provide a setter and getter for the wait-policy-var
ICV. Compilers from IBM, Cray and Oracle have provide this feature~\cite{ibmwait,craywait,oraclewait}.
There are also different variants of this features depending how much details users can configure
the wait policy.
\paragraph{1: {\sf omp\_set\_wait\_policy(ACTIVE$\vert$PASSIVE)} setter} for the wait-policy-var
ICV with ACTIVE or PASSIVE. This will allow programmer to explicitly change the policy at various 
points during a program's execution. An efficient implementation may use atomic write to the 
global ICV and all threads will react accordingly at some later point of the exectution after the 
ICV is set. So the effects may be delayed.

\paragraph{2: Finer-grained control with new environment variables and setter routine}



There are still some challenges in terms of OpenMP interoperability. 
OpenMP threads that are created by the parallel construct cannot interact with external systems. 
In other words, we are trying to enable the interoperability through flexible communication between OpenMP threads and user threads. 
However, the main goal of this work is to achieve a high level of resource utilization. So, it would be better if OpenMP threads can interact and communicate with user threads. To achieve this goal, we implement four new functions as follows:
\begin{enumerate}
	\item int omp{\_}set{\_}wait{\_}policy(ACTIVE \textbar PASSIVE): 
	set the waiting thread behavior. The function returns the current wait{\_}policy, which could be different from intention of the call depending on the decision made by the runtime. If the value is PASSIVE, waiting threads should not consume CPU power while waiting; while the value is ACTIVE specifies that they should.
	\item int omp{\_}thread{\_}create( ): 
	to give the user the ability to create an OpenMP thread without using \#pragma omp parallel directive, and lets it be a user thread similar to pthread.
	\item int ompe{\_}quiesce( ): 
	to shutdown or unload the OpenMP runtime library.
\end{enumerate}
