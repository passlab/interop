In conclusion, we have seen that there are many features can be added to the current 
OpenMP Runtime Library in order to improve the OpenMP interoperability. One feature is 
that allowing the user to create a new OpenMP thread and assign a task to it instead 
of creating new user thread. We have implement a function to allow users to get one 
thread from the existing thread pool is any threads are available, and assign one task 
to this thread, this helps to take advantage of the OpenMP thread pool and won’t need 
to create a new thread to work on it, which helps to save the memory usage and speed up the runtime.

We have studied the waiting policy of the OpenMP and how the current OpenMP Runtime System deals with the thread pool. Considering there are two waiting policies, one called throughput (passive), which is designed to make the program aware of its environment (that is, the system load) and to adjust its resource usage to produce efficient execution in a dynamic environment. While the other one called turnaround (active), which is designed to keep active all of the processors involved in the parallel computation in order to minimize the execution time of a single job. We cannot simply say which one is better than the other, it depends one the executing environment. When setting the wait policy to be passive, after a certain period of time has elapsed, the useless thread will stop waiting and sleep. Thus active mode may be better for high-density of OpenMP tasks. While, a passive mode with a small blocktime value may offer better overall performance if your application contains non-OpenMP threaded code that executes between parallel regions. 

In addition, we have implemented a new function to shutdown the whole runtime library when exiting the parallel region. Since all threads are maintained in the same thread pool, quiesce will reap every threads to free the memory, which sometimes help to clear the runtime environment when the task density is lower and we don’t need to wake up most of the thread in the thread pool. However, when entering new parallel regions, we need to make sure that we register the current working thread as our root thread, so that new runtime environment can be built on it. It cost time to restart another parallel region, thus works slower when lots of tasks in the task queue.

As a future work, we should continue adding more functions to the existing runtime system to improve the OpenMP interoperability, such as omp{\_}attach/omp{\_}detach, omp{\_}exit/omp{\_}join. By doing this, we could have a better OpenMP runtime library that optimizes the resources utilization.